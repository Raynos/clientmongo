{"name":"Clientmongo","body":"# clientmongo\r\n\r\nMongoDB in your browser\r\n\r\n## <a href=\"#Example\" name=\"Example\">Example</a>\r\n\r\n    // client.js\r\n    var Users = require(\"clientmongo\")(\"Users\")\r\n\r\n    Users.insert({ foo: \"bar\" }, function () {\r\n        Users.findOne({ foo: \"bar\" }, function (err, person) {\r\n            console.log(person.foo === \"bar\")\r\n        })\r\n    })\r\n\r\n    // server.js\r\n    var server = require(\"http\").createServer(),\r\n        clientmongo = require(\"clientmongo\")(server)\r\n\r\nTo clarify, you can run the exact same code that interacts with mongoDB in both the browser and the server using `clientmongo`.\r\n\r\nThe server-side instance of `clientmongo` does require a HTTP server to do communication over, so make sure to pass that in.\r\n\r\nThe client-side API matches the mongoDB docs for [Collection][1]. Any interaction with mongoDB on the browser is send to the server and persisted using the mongoDB driver on the server then the data is returned to the client.\r\n\r\nThink of this server-client data synchronization on steroids.\r\n\r\n## <a href=\"#Motivation\" name=\"Motivation\">But this is madness, why would you give clients access to the DB, they will troll you.</a>\r\n\r\nConsider a generic CRUD based website that has things like\r\n\r\n - GET /blog/:id\r\n - POST /blog\r\n - DELETE /blog/:id\r\n\r\netc. Now consider replacing that with\r\n\r\n - Blog.find({ id: id })\r\n - Blog.insert(doc)\r\n - Blog.remove({ id: id })\r\n\r\nAll it's doing is saving you the hassle of writing boilerplate serverside code. \r\n\r\nIt's like [Backbone.sync][1] but the backend is written for you.\r\n\r\nYou can also hook a session based [Auth system][2] into the API to limit DB access. \r\n\r\nIt's just taking the \"database on the client\" concept from [firebase][3] and [meteor][4] and giving you access to a database on the client in a simple singular module.\r\n\r\nIt's taking the concept of a SPA to the next level, rather then writing a backend to handle data storage you write a backend that implements the authorization rules on the database and talk to the database on the client.\r\n\r\n  [1]: http://documentcloud.github.com/backbone/#Sync\r\n  [2]: https://github.com/Raynos/clientmongo#Auth\r\n  [3]: http://www.firebase.com/\r\n  [4]: http://meteor.com/\r\n\r\n## <a href=\"#Further\" name=\"Further\">Further Examples</a>\r\n\r\n - [The same unit test suite of clientmongo can be run on both client and server][2]\r\n - [examples folder][3]\r\n\r\n## <a href=\"#Disclaimers\" name=\"Disclaimers\">Disclaimers</a>\r\n\r\nYou still need to run a backend, you still need to run node.js, you still need to run mongoDB on the server. You need to create a node.js HTTP server and pass it into clientmongo on the server, and only then can you use clientmongo on the client.\r\n\r\nYou also need to build clientmongo using a browserify as your commonJS compiler.\r\n\r\nYou also need to implement your own session system and auth system for this to work, you need to give your browsers authTokens that you can then match to \"users\" on the server and limit their database access through a role system that you need to implement\r\n\r\n  [1]: http://mongodb.github.com/node-mongodb-native/api-generated/collection.html\r\n  [2]: https://github.com/Raynos/clientmongo#Tests\r\n  [3]: https://github.com/Raynos/clientmongo/tree/master/examples","tagline":"Use the mongo API in the browser","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}